(window.webpackJsonp=window.webpackJsonp||[]).push([[172],{541:function(n,e,t){"use strict";t.r(e);var s=t(24),a=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"react-事件机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-事件机制"}},[n._v("#")]),n._v(" React 事件机制")]),n._v(" "),t("h2",{attrs:{id:"浏览器事件委托"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器事件委托"}},[n._v("#")]),n._v(" 浏览器事件委托")]),n._v(" "),t("p",[n._v("假设有如下 html，我们想要在每个 li 上绑定 onClick 事件，最直观的做法当然就是给每个 li 分别添加事件，增加事件回调。这种做法当然没错，但是我们有一种更好的做法，那就是在 ul 上添加有个监听事件，由于事件的冒泡机制，事件就会冒泡到 ul 上，因为 ul 上有事件监听，所以事件就会触发。")]),n._v(" "),t("p",[n._v("Event 对象提供了一个属性叫 target，可以返回事件的目标节点，我们称为事件源，也就是说，target 就可以表示为触发当前的事件 dom，我们可以根据 dom 进行判断到底是哪个元素触发了事件，根据不同的元素，执行不同的回调方法。")]),n._v(" "),t("p",[t("strong",[n._v("事件委托有以下优点")]),n._v("：")]),n._v(" "),t("ol",[t("li",[n._v("减少事件注册,节省内存，能够提升整体性能。")]),n._v(" "),t("li",[n._v("简化了 dom 节点更新时,相应事件的更新（用过 jquery 的都知道，动态加入的元素，事件需要重新绑定）。")])]),n._v(" "),t("h2",{attrs:{id:"react-事件机制-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-事件机制-2"}},[n._v("#")]),n._v(" React 事件机制")]),n._v(" "),t("blockquote",[t("p",[n._v("React 并不是将 click 事件直接绑定在 dom 上面，而是采用事件冒泡的形式冒泡到 document 上面，这个思路借鉴了事件委托机制。所以，React 中所有的事件最后都是被委托到了 document 这个顶级 DOM 上。")])]),n._v(" "),t("h3",{attrs:{id:"react-事件流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-事件流程"}},[n._v("#")]),n._v(" React 事件流程")]),n._v(" "),t("div",{staticClass:"language-js line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[n._v("/**\n *\n * Overview of React and the event system:\n *\n * +------------+    .\n * |    DOM     |    .\n * +------------+    .\n *       |           .\n *       v           .\n * +------------+    .\n * | ReactEvent |    .\n * |  Listener  |    .\n * +------------+    .                         +-----------+\n *       |           .               +--------+|SimpleEvent|\n *       |           .               |         |Plugin     |\n * +-----|------+    .               v         +-----------+\n * |     |      |    .    +--------------+                    +------------+\n * |     +-----------.---\x3e|EventPluginHub|                    |    Event   |\n * |            |    .    |              |     +-----------+  | Propagators|\n * | ReactEvent |    .    |              |     |TapEvent   |  |------------|\n * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|\n * |            |    .    |              |     +-----------+  |  utilities |\n * |     +-----------.---\x3e|              |                    +------------+\n * |     |      |    .    +--------------+\n * +-----|------+    .                ^        +-----------+\n *       |           .                |        |Enter/Leave|\n *       +           .                +-------+|Plugin     |\n * +-------------+   .                         +-----------+\n * | application |   .\n * |-------------|   .\n * |             |   .\n * |             |   .\n * +-------------+   .\n *                   .\n */")]),n._v("\n")])]),n._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[n._v("1")]),t("br"),t("span",{staticClass:"line-number"},[n._v("2")]),t("br"),t("span",{staticClass:"line-number"},[n._v("3")]),t("br"),t("span",{staticClass:"line-number"},[n._v("4")]),t("br"),t("span",{staticClass:"line-number"},[n._v("5")]),t("br"),t("span",{staticClass:"line-number"},[n._v("6")]),t("br"),t("span",{staticClass:"line-number"},[n._v("7")]),t("br"),t("span",{staticClass:"line-number"},[n._v("8")]),t("br"),t("span",{staticClass:"line-number"},[n._v("9")]),t("br"),t("span",{staticClass:"line-number"},[n._v("10")]),t("br"),t("span",{staticClass:"line-number"},[n._v("11")]),t("br"),t("span",{staticClass:"line-number"},[n._v("12")]),t("br"),t("span",{staticClass:"line-number"},[n._v("13")]),t("br"),t("span",{staticClass:"line-number"},[n._v("14")]),t("br"),t("span",{staticClass:"line-number"},[n._v("15")]),t("br"),t("span",{staticClass:"line-number"},[n._v("16")]),t("br"),t("span",{staticClass:"line-number"},[n._v("17")]),t("br"),t("span",{staticClass:"line-number"},[n._v("18")]),t("br"),t("span",{staticClass:"line-number"},[n._v("19")]),t("br"),t("span",{staticClass:"line-number"},[n._v("20")]),t("br"),t("span",{staticClass:"line-number"},[n._v("21")]),t("br"),t("span",{staticClass:"line-number"},[n._v("22")]),t("br"),t("span",{staticClass:"line-number"},[n._v("23")]),t("br"),t("span",{staticClass:"line-number"},[n._v("24")]),t("br"),t("span",{staticClass:"line-number"},[n._v("25")]),t("br"),t("span",{staticClass:"line-number"},[n._v("26")]),t("br"),t("span",{staticClass:"line-number"},[n._v("27")]),t("br"),t("span",{staticClass:"line-number"},[n._v("28")]),t("br"),t("span",{staticClass:"line-number"},[n._v("29")]),t("br"),t("span",{staticClass:"line-number"},[n._v("30")]),t("br"),t("span",{staticClass:"line-number"},[n._v("31")]),t("br"),t("span",{staticClass:"line-number"},[n._v("32")]),t("br"),t("span",{staticClass:"line-number"},[n._v("33")]),t("br"),t("span",{staticClass:"line-number"},[n._v("34")]),t("br"),t("span",{staticClass:"line-number"},[n._v("35")]),t("br")])]),t("p",[n._v("从这个图可以看出，Dom 事件发生后，React 通过事件委托机制将大部分事件代理至 Document 层，ReactEventListener 就是负责给元素绑定事件的。ReactEventEmitter 暴露接口给 React 组件层用于添加事件订阅（对外暴露了 listenTo 等方法）。EventPluginHub 负责管理和注册各种插件。在事件分发时，调用插件来生成合成事件。 React 事件系统使用了插件机制来管理不同行为的事件。这些插件会处理自己感兴趣的事件类型，并生成合成事件对象。")]),n._v(" "),t("p",[n._v("比如 "),t("code",[n._v("SimpleEventPlugin")]),n._v(" 负责处理一些比较通用的事件类型，如"),t("code",[n._v("blur、focus、click、submit、touchMove、mouseMove、scroll、drag、load")]),n._v("。")]),n._v(" "),t("p",[t("strong",[n._v("EnterLeaveEventPlugin")]),n._v(" 负责处理 "),t("code",[n._v("mouseEnter/mouseLeave")]),n._v(" 和 "),t("code",[n._v("pointerEnter/pointerLeave")]),n._v(" 这两类事件，"),t("strong",[n._v("单独处理的原因是这两类事件不支持冒泡")]),n._v("。")]),n._v(" "),t("p",[t("strong",[n._v("TapEventPlugin")]),n._v(" 是为了解决移动端 IOS 300ms 点击延迟，该插件增加了一个 "),t("code",[n._v("onTouchTap")]),n._v(" 事件，这个事件触发后，会忽略 300ms 后的 onClick 事件。")]),n._v(" "),t("p",[n._v("这里还需要了解的是，EventPluginHub 中处理的时间其实是合成事件 (SyntheticEvent)，React 为什么要定义合成事件这个概念呢，有三点原因：")]),n._v(" "),t("ol",[t("li",[n._v("合成事件 "),t("code",[n._v("SyntheticEvent")]),n._v(" 可以认为是"),t("strong",[n._v("浏览器原生事件跨浏览器的封装")]),n._v("，相当于 React 帮我们做了浏览器的兼容性处理。")]),n._v(" "),t("li",[n._v("React 想通过 "),t("code",[n._v("SyntheticEvent")]),n._v(" 实现跨平台事件机制。")]),n._v(" "),t("li",[n._v("原生事件升级、改造，比如 React 的 "),t("code",[n._v("onChange")]),n._v(" 事件，它为表单元素定义了统一的值变动事件，例如 "),t("code",[n._v("blur")]),n._v("、"),t("code",[n._v("change")]),n._v("、"),t("code",[n._v("focus")]),n._v("、"),t("code",[n._v("input")]),n._v(" 等。")])]),n._v(" "),t("p",[n._v("对于依赖的原生事件，scroll blur focus cancel close 方法注册捕获阶段的事件监听器。invalid submit reset 事件不做处理。剩下的事件需要判断是否是媒体触发的，比如 video / audio 的 onplaying 事件，onprogress 事件， onratechange 事件等，这些媒体事件也不需要处理。")]),n._v(" "),t("p",[n._v("React 这么做的原因和事件有关，有些事件是不冒泡的，所以不能在冒泡阶段进行事件委托。"),t("br"),n._v("\nDiscreteEvent：click，blur,focus,submit,tuchStart 等，优先级是 0。\nUserBlockingEvent：touchMove,mouseMove,scroll,drag,dragOver 等，这些事件会阻塞用户的交互，优先级是 1。\nContinuousEvent：load,error,loadStart,abort,animationend 等，优先级是 2，这个优先级最高，不会被打断。\n根据优先级的不同，监听函数做了不同的包装，我们先不管这里生成的监听函数和最初的监听方法有什么不同。最终我们会调用 addEventBubbleListener 方法。")]),n._v(" "),t("p",[n._v("addEventBubbleListener 就是 element.addEventListener，为目标添加事件监听函数。")]),n._v(" "),t("ol",[t("li",[n._v("React 借鉴事件委托的方式将大部分事件委托给了 Document 对象。")]),n._v(" "),t("li",[n._v("React 中的事件分为 3 类。分别是 DiscreteEvent（离散事件），UserBlockingEvent（用户阻塞事件），ContinuousEvent（连续事件）。")]),n._v(" "),t("li",[n._v("不同类型的事件代表了不同的优先级。\n事件委托需要区分捕获和冒泡，有些事件由于没有冒泡过程，只能在捕获阶段进行事件委托。")]),n._v(" "),t("li",[n._v("没有进行委托的事件是 Form 事件和 Media 事件，原因是这些事件委托后会触发两次回调函数。")])])])}),[],!1,null,null,null);e.default=a.exports}}]);