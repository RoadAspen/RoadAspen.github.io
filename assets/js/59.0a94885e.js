(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{430:function(t,s,a){"use strict";a.r(s);var v=a(24),e=Object(v.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"eventloop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eventloop"}},[t._v("#")]),t._v(" EventLoop")]),t._v(" "),a("p",[t._v("javascript 是单线程，非阻塞的，当异步函数完成执行回调时重回到事件循环中。这就是"),a("code",[t._v("javascript事件循环机制")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[t._v("#")]),t._v(" 单线程")]),t._v(" "),a("h3",{attrs:{id:"什么是单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是单线程"}},[t._v("#")]),t._v(" 什么是单线程")]),t._v(" "),a("p",[t._v("js 诞生之初就是单线程，主程序只有一个线程，并且同一时间片段内只能执行单个任务。")]),t._v(" "),a("h3",{attrs:{id:"为什么是单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么是单线程"}},[t._v("#")]),t._v(" 为什么是单线程")]),t._v(" "),a("p",[t._v("js 的单线程主要在于 js 的用途，js 作为浏览器脚本语言，主要用途是为了用户互动、操作 DOM，这决定了它只能是单线程，如果是多线程，那么两个线程同时对同一个 DOM 节点作出修改，一个添加，一个删除，那么浏览器该如何做出展示？ 基于此，javascript 从诞生之初就是单线程，这已经是 javascript 这门语言的核心特征，将来也不会改变。"),a("br"),t._v("\n为了利用多核 CPU 的计算能力，HTML5 提出了 WebWorker 标准，允许 javascript 创建多个线程，但是 web worker 不能操作 DOM，且子线程完全受主线程控制，本质上并没有改变 javascript 是单线程的事实。")]),t._v(" "),a("h3",{attrs:{id:"单线程意味着什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单线程意味着什么"}},[t._v("#")]),t._v(" 单线程意味着什么")]),t._v(" "),a("p",[t._v("就像奶茶店，排号制作奶茶，只有前边的人的订单做好了，才能做好你的\n"),a("strong",[t._v("javascript 是单线程")]),t._v("，单线程就意味着，所有的任务都需要排队，当前一个任务结束，下一个任务才会开始执行。如果一个任务耗时过长，后边的任务就会一直等着。")]),t._v(" "),a("h3",{attrs:{id:"怎么解决单线程的阻塞问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#怎么解决单线程的阻塞问题"}},[t._v("#")]),t._v(" 怎么解决单线程的阻塞问题")]),t._v(" "),a("p",[t._v("任务一般分为 "),a("strong",[t._v("CPU 密集型")]),t._v("，"),a("strong",[t._v("I/O 密集型")]),t._v(" ,js 把任务分为两种，一种是"),a("strong",[t._v("同步任务")]),t._v("，一种是"),a("strong",[t._v("异步任务")]),t._v("。异步任务指的是，不进入主线程，而是进入任务队列（task queue），只有执行栈空了，主线程通知任务队列，某个异步任务可以执行了，该任务才会进入主线程执行。")]),t._v(" "),a("h2",{attrs:{id:"javascript-内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-内存"}},[t._v("#")]),t._v(" javascript 内存")]),t._v(" "),a("h3",{attrs:{id:"堆-heap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[t._v("#")]),t._v(" 堆（heap）")]),t._v(" "),a("p",[t._v("堆表示一大块非结构化的内存区域，对象，数据被存放在堆中")]),t._v(" "),a("h3",{attrs:{id:"栈-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#栈-stack"}},[t._v("#")]),t._v(" 栈（stack）")]),t._v(" "),a("p",[t._v("栈，又叫执行栈，是一种"),a("code",[t._v("后进先出")]),t._v("的数据结构。javascript 有一个主线程和调用栈，主线程的所有任务都会被放到调用栈等待主线程执行。当函数执行时会被添加到栈的顶部，当函数执行完后就会从栈顶移出，直到栈内被清空。")]),t._v(" "),a("h3",{attrs:{id:"队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),a("p",[a("strong",[t._v("任务队列")]),t._v(" 即 Task Queue 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"),a("strong",[t._v("任务队列")]),t._v("底部第一个的事件就自动进入主进程。但是，由于存在"),a("strong",[t._v("定时器")]),t._v("功能，主线程首先要检查一下执行时间，某个事件只有到了规定的时间，才能返回主线程。")]),t._v(" "),a("h2",{attrs:{id:"javascript-代码执行机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-代码执行机制"}},[t._v("#")]),t._v(" Javascript 代码执行机制")]),t._v(" "),a("p",[a("img",{attrs:{src:"/js/eventloop/eventloop.jpg",alt:"EventLoop"}})]),t._v(" "),a("ol",[a("li",[t._v("所有的同步任务都在主线程上执行，形成一个"),a("strong",[t._v("执行栈(stack)")]),t._v("。")]),t._v(" "),a("li",[t._v("主线程之外，还有一个"),a("strong",[t._v("任务队列(callback queue)")]),t._v("。只要异步任务有了结果，就在任务队列中放置一个事件。")]),t._v(" "),a("li",[t._v("一旦执行栈中的"),a("strong",[t._v("所有同步任务执行完毕")]),t._v("，系统就会读取任务队列，看看里面有哪些事件，那些对应的异步任务，结束等待状态，进入执行栈开始执行。")]),t._v(" "),a("li",[a("strong",[t._v("主线程不断的重复上面的第三步")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),a("p",[t._v("只要主线程执行栈空了，就会去读取任务队列，这就是 javascript 的运行机制 EventLoop。主线程从"),a("strong",[t._v("任务队列")]),t._v("中读取事件，这个过程是不断循环的，所以整个的这种运行机制又称为 Event Loop（事件循环）。")]),t._v(" "),a("h3",{attrs:{id:"异步任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步任务"}},[t._v("#")]),t._v(" 异步任务")]),t._v(" "),a("p",[t._v("js 中的异步任务又分为 微任务 和 宏任务")]),t._v(" "),a("h4",{attrs:{id:"macro-task"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#macro-task"}},[t._v("#")]),t._v(" macro task")]),t._v(" "),a("p",[t._v("宏任务有以下几种：")]),t._v(" "),a("ol",[a("li",[t._v("I/O")]),t._v(" "),a("li",[t._v("setTimeout")]),t._v(" "),a("li",[t._v("setInterval")]),t._v(" "),a("li",[t._v("setImmediate(Node 环境)")]),t._v(" "),a("li",[t._v("UI rendering(页面重绘)")]),t._v(" "),a("li",[t._v("requestAnimationFrame(在下一次页面重绘之前执行)")])]),t._v(" "),a("h4",{attrs:{id:"micro-task"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#micro-task"}},[t._v("#")]),t._v(" micro task")]),t._v(" "),a("p",[t._v("微任务有以下几种：")]),t._v(" "),a("ol",[a("li",[t._v("promise.then")]),t._v(" "),a("li",[t._v("process.nextTick(Node 环境)")]),t._v(" "),a("li",[t._v("MutationObserver (监视 DOM 变动，DOM 变动会触发这个事件)")])]),t._v(" "),a("p",[t._v("在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。")]),t._v(" "),a("h2",{attrs:{id:"定时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器"}},[t._v("#")]),t._v(" 定时器")]),t._v(" "),a("p",[t._v("除了异步任务，"),a("strong",[t._v("任务队列还可以放置定时器，即指定一段时间后执行一段代码")]),t._v("。这就是"),a("strong",[t._v("定时器")]),t._v("。\n定时器主要功能主要由 "),a("em",[t._v("setTimeout")]),t._v(" 和 "),a("em",[t._v("setInterval")]),t._v("两个函数完成，他们的内部运行机制完全一样，区别在于前者指定的代码是一次性的，后者则是反复执行。他们接收"),a("strong",[t._v("两个参数")]),t._v("（第三个以及之后的参数为第一个函数参数的参数），第一个参数是"),a("strong",[t._v("回调函数")]),t._v("，第二个参数是"),a("strong",[t._v("等待时间")]),t._v("。等待时间指的是在一段时间后的主线程的空闲时间执行。如果是 0，eg: "),a("code",[t._v("setTimeout(fn,0)")]),t._v(", 指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早的执行。他在任务队列的尾部添加一个事件，因此要等到"),a("strong",[t._v("同步任务")]),t._v("和"),a("strong",[t._v("任务队列")]),t._v("中现有的事件都处理完，才会得到执行。")]),t._v(" "),a("p",[t._v("HTML5 标准规定了 setTimeout 的第二个参数的最小值，不得低于 4ms，就是说，如果低于这个值，也会按照 4ms 执行，在此之前浏览器将最短时间间隔设为 10ms。 对于哪些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16ms 执行一次。这时使用 "),a("code",[t._v("requestAnimationFrame()")]),t._v(" 的效果要好于 setTimeout（）。 需要注意的是，setTimeout 只是将事件插入了"),a("strong",[t._v("任务队列")]),t._v("，执行依然要等到主线程执行完毕，读取"),a("strong",[t._v("任务队列")]),t._v("时，才会执行到 setTimeout 的回调函数，如果主线程耗时较长，那么就没有办法保证回调函数一定会在 setTimeout 指定的时间执行。")]),t._v(" "),a("h2",{attrs:{id:"node-js-的-event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js-的-event-loop"}},[t._v("#")]),t._v(" Node.js 的 Event Loop")]),t._v(" "),a("p",[t._v("Node.js 也是单线程的 Event Loop， 但是他的运行机制不同于浏览器环境。")]),t._v(" "),a("ol",[a("li",[t._v("V8 引擎解析 javascript 脚本。")]),t._v(" "),a("li",[t._v("解析后的代码，调用 Node api。")]),t._v(" "),a("li",[t._v("libuv 库负责 Node API 的执行。它将不同的任务分配给不同的线程，形成一个 Event Loop,以异步的方式将任务的执行结果返回给 V8 引擎。")]),t._v(" "),a("li",[t._v("V8 引擎再将结果返回给用户。")])]),t._v(" "),a("p",[t._v("除了"),a("code",[t._v("setTimeout")]),t._v(" 和 "),a("code",[t._v("setInterval")]),t._v(" 这两个方法，Node.js 还提供了另外两个与"),a("strong",[t._v("任务队列有关的方法")]),t._v("："),a("strong",[t._v("process.nextTick")]),t._v("和"),a("strong",[t._v("setImmediate")]),t._v("。它们可以帮助我们加深对"),a("strong",[t._v("任务队列的理解")]),t._v("，这两个方法只有一个函数参数。")]),t._v(" "),a("p",[a("code",[t._v("process.nextTick")]),t._v(" 方法可以在"),a("strong",[t._v("当前执行栈")]),t._v("的尾部，下一次 Event Loop 之前，触发回调函数。"),a("strong",[t._v("它总是发生在所有异步任务之前")]),t._v("。"),a("br"),t._v(" "),a("code",[t._v("setImmediate")]),t._v(" 方法则在 "),a("strong",[t._v("当前任务队列的尾部")]),t._v("添加事件，也就是说，它指定的任务总是在下一次 Event Loop 时执行，这和 "),a("code",[t._v("setTimeout(fn,0)")]),t._v(" 很像。"),a("br"),t._v("\n最新版 nodejs 推荐使用 "),a("code",[t._v("setImmediate")]),t._v("，因为 nextTick 可能阻断 IO。")]),t._v(" "),a("p",[a("strong",[t._v('如果有多个 process.nextTick 语句（不管它们是否嵌套），将全部在当前"执行栈"执行。')]),a("br"),t._v(" "),a("strong",[t._v('多个 process.nextTick 语句总是在当前"执行栈"一次执行完，多个 setImmediate 可能则需要多次 loop 才能执行完')])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 无限循环")]),t._v("\nprocess"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextTick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  process"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextTick")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("p",[t._v("理解 javascript 的 事件循环机制，对程序的理解会更加的深入。")])])}),[],!1,null,null,null);s.default=e.exports}}]);